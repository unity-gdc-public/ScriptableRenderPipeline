#pragma kernel ValidateHistory

#pragma kernel TemporalAccumulationSingle   TEMPORAL_ACCUMULATION=TemporalAccumulationSingle SINGLE_CHANNEL
#pragma kernel TemporalAccumulationColor    TEMPORAL_ACCUMULATION=TemporalAccumulationColor

#pragma kernel CopyHistorySingle            COPY_HISTORY=CopyHistorySingle SINGLE_CHANNEL
#pragma kernel CopyHistoryColor             COPY_HISTORY=CopyHistoryColor 

#pragma kernel BilateralFilterSingle        BILATERAL_FILTER=BilateralFilterSingle     SINGLE_CHANNEL
#pragma kernel BilateralFilterColor         BILATERAL_FILTER=BilateralFilterColor

#pragma kernel GatherSingle                 GATHER_FILTER=GatherSingle     SINGLE_CHANNEL
#pragma kernel GatherColor                  GATHER_FILTER=GatherColor

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/NormalBuffer.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingSampling.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/OnlineVariance.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Builtin/BuiltinData.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/PostProcessing/Shaders/TemporalAntialiasing.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/CommonLighting.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Sampling/Sampling.hlsl"

#pragma enable_d3d11_debug_symbols

// Tile size of this compute
#define SPATIO_TEMPORAL_TILE_SIZE 8

TEXTURE2D_X(_DepthTexture);
TEXTURE2D_X(_EdgeDetection);
TEXTURE2D_X(_HistoryDepthTexture);
TEXTURE2D_X(_HistoryNormalBufferTexture);
RW_TEXTURE2D_X(uint, _HistoryValidityBuffer);
uint _NormalHistoryCriterion;

[numthreads(SPATIO_TEMPORAL_TILE_SIZE, SPATIO_TEMPORAL_TILE_SIZE, 1)]
void ValidateHistory(uint2 groupThreadId : SV_GroupThreadID, uint2 groupId : SV_GroupID)
{
    // Fetch the current pixel coordinates
    uint2 centerCoord = groupId * SPATIO_TEMPORAL_TILE_SIZE + groupThreadId;

    // Get the posinputs of the current version of the pixel
    float depth = LOAD_TEXTURE2D_X(_DepthTexture, centerCoord).r;
    PositionInputs posInputs = GetPositionInput(centerCoord, _ScreenSize.zw, depth, UNITY_MATRIX_I_VP, UNITY_MATRIX_V);
    if ( depth == UNITY_RAW_FAR_CLIP_VALUE)
    {
        _HistoryValidityBuffer[COORD_TEXTURE2D_X(centerCoord)] = 0;
        return;
    }

    // Get the closest pixel coord
    float2 closest = GetClosestFragment(posInputs);

    // Decode the velocity of the pixel
    float2 velocity = float2(0.0, 0.0);
    DecodeMotionVector(LOAD_TEXTURE2D_X(_CameraMotionVectorsTexture, closest), velocity);
    float velocityLength = length(velocity);

    float2 uv = posInputs.positionNDC;

    // Read the history depth and cmpute the world space position
    float historyDepth = Fetch4(_HistoryDepthTexture, posInputs.positionNDC - velocity, 0.0, _RTHandleScaleHistory.xy).x;
    if ( historyDepth == UNITY_RAW_FAR_CLIP_VALUE)
    {
        _HistoryValidityBuffer[COORD_TEXTURE2D_X(centerCoord)] = 0;
        return;
    }

    float3 historyPositionWS = ComputeWorldSpacePosition(posInputs.positionNDC - velocity, historyDepth, UNITY_MATRIX_PREV_I_VP);
    float4 normalSmoothness = Fetch4(_NormalBufferTexture, uv, 0.0, _RTHandleScale.xy);
    float4 historyNormalSmoothness = Fetch4(_HistoryNormalBufferTexture, posInputs.positionNDC - velocity, 0.0, _RTHandleScaleHistory.xy);

    NormalData normalData;
    DecodeFromNormalBuffer(normalSmoothness, uint2(0,0), normalData);
    NormalData historyNormalData;
    DecodeFromNormalBuffer(historyNormalSmoothness, uint2(0,0), historyNormalData);

    // 0b1111 
    // -> First bit flags if the pixel is inside the screen
    // -> Second bit flags if the pixel world space positions match
    // -> Third bit flags if the pixel world space normals match
    // -> Fourth bit flags if the pixel smoothness match

    uint validityFlag = 0xF;
    float2 uvHistory = (posInputs.positionNDC - velocity) *  _RTHandleScaleHistory.xy;
    if (uvHistory.x < 0.0 || uvHistory.x > 1.0 || uvHistory.y < 0.0 || uvHistory.y > 1.0)
    {
        validityFlag = 0xE;
    }

    if (length (historyPositionWS - (posInputs.positionWS)) > 0.01)
    {
        validityFlag = 0xD;
    }
    
    if (_NormalHistoryCriterion != 0 && dot (normalData.normalWS, historyNormalData.normalWS) < 0.9)
    {
        validityFlag = 0xB;
    }
    _HistoryValidityBuffer[COORD_TEXTURE2D_X(centerCoord)] = validityFlag;
}

TEXTURE2D_X(_DenoiseInputTexture);
TEXTURE2D_X(_HistoryBuffer);
#if SINGLE_CHANNEL
RW_TEXTURE2D_X(float, _DenoiseOutputTextureRW);
#else
RW_TEXTURE2D_X(float4, _DenoiseOutputTextureRW);
#endif
[numthreads(SPATIO_TEMPORAL_TILE_SIZE, SPATIO_TEMPORAL_TILE_SIZE, 1)]
void TEMPORAL_ACCUMULATION(uint2 groupThreadId : SV_GroupThreadID, uint2 groupId : SV_GroupID)
{
    // Fetch the current pixel coordinate
    uint2 centerCoord = groupId * SPATIO_TEMPORAL_TILE_SIZE + groupThreadId;

    float depth = LOAD_TEXTURE2D_X(_DepthTexture, centerCoord).r;
    if (depth == UNITY_RAW_FAR_CLIP_VALUE)
    {
        #if SINGLE_CHANNEL
        _DenoiseOutputTextureRW[COORD_TEXTURE2D_X(centerCoord)] = 0.0;
        #else
        _DenoiseOutputTextureRW[COORD_TEXTURE2D_X(centerCoord)] = float4(0.0, 0.0, 0.0, 1.0);
        #endif
        return;
    }

    PositionInputs posInputs = GetPositionInput(centerCoord, _ScreenSize.zw, depth, UNITY_MATRIX_I_VP, UNITY_MATRIX_V);

    float2 closest = GetClosestFragment(posInputs);

    float2 velocity = float2(0.0, 0.0);
    DecodeMotionVector(LOAD_TEXTURE2D_X(_CameraMotionVectorsTexture, closest), velocity);
    float velocityLength = length(velocity);

    float2 uv = posInputs.positionNDC;

    #if SINGLE_CHANNEL
    float color = Fetch4(_DenoiseInputTexture, uv, 0.0, _RTHandleScale.xy).x;
    float history = Fetch4(_HistoryBuffer, posInputs.positionNDC - velocity, 0.0, _RTHandleScaleHistory.xy).x;
    #else
    float3 color = Fetch4(_DenoiseInputTexture, uv, 0.0, _RTHandleScale.xy).xyz;
    float3 history = Fetch4(_HistoryBuffer, posInputs.positionNDC - velocity, 0.0, _RTHandleScaleHistory.xy).xyz;
    #endif
    float accumulationFactor = 0.97;
    if(_HistoryValidityBuffer[COORD_TEXTURE2D_X(centerCoord)] != 0xF)
    {
        accumulationFactor = 0.0;
    }
    #if SINGLE_CHANNEL
    _DenoiseOutputTextureRW[COORD_TEXTURE2D_X(centerCoord)] = color * (1.0 - accumulationFactor) + history * accumulationFactor;
    #else
    _DenoiseOutputTextureRW[COORD_TEXTURE2D_X(centerCoord)] = float4(color * (1.0 - accumulationFactor) + history * accumulationFactor, 1.0);
    #endif
}

[numthreads(SPATIO_TEMPORAL_TILE_SIZE, SPATIO_TEMPORAL_TILE_SIZE, 1)]
void COPY_HISTORY(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    UNITY_STEREO_ASSIGN_COMPUTE_EYE_INDEX(dispatchThreadId.z);

    if (any(dispatchThreadId.xy > uint2(_ScreenSize.xy)))
        return;  // Out of bounds, discard
    #if SINGLE_CHANNEL
    _DenoiseOutputTextureRW[COORD_TEXTURE2D_X(dispatchThreadId.xy)] = _DenoiseInputTexture[COORD_TEXTURE2D_X(dispatchThreadId.xy)].x;
    #else
    _DenoiseOutputTextureRW[COORD_TEXTURE2D_X(dispatchThreadId.xy)] = float4(_DenoiseInputTexture[COORD_TEXTURE2D_X(dispatchThreadId.xy)].xyz, 1.0);
    #endif
}

// ----------------------------------------------------------------------------
// Denoising Kernel
// ----------------------------------------------------------------------------

// Couple helper functions
float sqr(float value)
{
    return value * value;
}
float gaussian(float radius, float sigma)
{
    return exp(-sqr(radius / sigma));
}

// Bilateral filter parameters
#define NORMAL_WEIGHT   1.0
#define PLANE_WEIGHT    1.0
#define DEPTH_WEIGHT    1.0

struct BilateralData
{
    float3 position;
    float  z01;
    float  zNF;
    float3 normal;
};

BilateralData TapBilateralData(uint2 coordSS)
{
    BilateralData key;
    PositionInputs posInput;

    if (DEPTH_WEIGHT > 0.0 || PLANE_WEIGHT > 0.0)
    {
        posInput.deviceDepth = LOAD_TEXTURE2D_X(_DepthTexture, coordSS).r;
        key.z01 = Linear01Depth(posInput.deviceDepth, _ZBufferParams);
        key.zNF = LinearEyeDepth(posInput.deviceDepth, _ZBufferParams);
    }

    if (PLANE_WEIGHT > 0.0)
    {
        posInput = GetPositionInput(coordSS, _ScreenSize.zw, posInput.deviceDepth, UNITY_MATRIX_I_VP, UNITY_MATRIX_V);
        key.position = posInput.positionWS;
    }

    if ((NORMAL_WEIGHT > 0.0) || (PLANE_WEIGHT > 0.0))
    {
        NormalData normalData;
        const float4 normalBuffer = LOAD_TEXTURE2D_X(_NormalBufferTexture, coordSS);
        DecodeFromNormalBuffer(normalBuffer, coordSS, normalData);
        key.normal = normalData.normalWS;
    }

    return key;
}

float ComputeBilateralWeight(BilateralData center, BilateralData tap)
{
    float depthWeight    = 1.0;
    float normalWeight   = 1.0;
    float planeWeight    = 1.0;

    if (DEPTH_WEIGHT > 0.0)
    {
        depthWeight = max(0.0, 1.0 - abs(tap.z01 - center.z01) * DEPTH_WEIGHT);
    }

    if (NORMAL_WEIGHT > 0.0)
    {
        const float normalCloseness = sqr(sqr(max(0.0, dot(tap.normal, center.normal))));
        const float normalError = 1.0 - normalCloseness;
        normalWeight = max(0.0, (1.0 - normalError * NORMAL_WEIGHT));
    }

    if (PLANE_WEIGHT > 0.0)
    {
        // Change in position in camera space
        const float3 dq = center.position - tap.position;

        // How far away is this point from the original sample
        // in camera space? (Max value is unbounded)
        const float distance2 = dot(dq, dq);

        // How far off the expected plane (on the perpendicular) is this point? Max value is unbounded.
        const float planeError = max(abs(dot(dq, tap.normal)), abs(dot(dq, center.normal)));

        planeWeight = (distance2 < 0.0001) ? 1.0 :
            pow(max(0.0, 1.0 - 2.0 * PLANE_WEIGHT * planeError / sqrt(distance2)), 2.0);
    }

    return depthWeight * normalWeight * planeWeight;
}

float _DenoiserFilterRadius;
int _HalfResolutionFilter;

[numthreads(SPATIO_TEMPORAL_TILE_SIZE, SPATIO_TEMPORAL_TILE_SIZE, 1)]
void BILATERAL_FILTER(uint2 groupThreadId : SV_GroupThreadID, uint2 groupId : SV_GroupID)
{
    // Fetch the current pixel coordinate
    uint2 centerCoord = groupId * SPATIO_TEMPORAL_TILE_SIZE + groupThreadId;

    // Read the central position
    const BilateralData center = TapBilateralData(centerCoord);

    // If this is a background pixel, we are done
    if (center.z01 == 1.0)
    {
        #if SINGLE_CHANNEL
        _DenoiseOutputTextureRW[COORD_TEXTURE2D_X(centerCoord)] = 0.0;
        #else
        _DenoiseOutputTextureRW[COORD_TEXTURE2D_X(centerCoord)] = float4(0.0, 0.0, 0.0, 1.0);
        #endif
    }

    // Create the local ortho basis for our sampling
    float3x3 localToWorld = GetLocalFrame(center.normal);

    // Intialize the accumulation values
    #if SINGLE_CHANNEL
    float colorSum = 0.0;
    float wSum = 0.0;
    #else
    float3 colorSum = 0.0;
    float wSum = 0.0;
    #endif

    // Define the sample count for this pixel
    float hcoord = saturate(length(centerCoord * _ScreenSize.zw * 2.0 - 1.0) * 0.70710678118) * InterleavedGradientNoise(centerCoord, (uint)_TaaFrameInfo.z);
    int numSamples = _HalfResolutionFilter ? 4 : 16;

    int localIndex = (centerCoord.x & 1) + (centerCoord.y & 1) * 2;
    const float sigma = 0.5 * _DenoiserFilterRadius;

    for (uint sampleIndex = 0; sampleIndex < (uint)numSamples; ++sampleIndex)
    {
        float2 sample = GetRaytracingNoiseSampleRG(sampleIndex + (_HalfResolutionFilter != 0 ? localIndex * numSamples : 0));
        sample = SampleDiskUniform(sample.x * sample.x, sample.y);

        sample *= _DenoiserFilterRadius;
        sample *= _DenoiserFilterRadius;
        sample *= _DenoiserFilterRadius;

        float3 wsPos = center.position + localToWorld[0] * sample.x + localToWorld[1] * sample.y;
        float4 hClip = TransformWorldToHClip(wsPos);
        hClip.xyz /= hClip.w;

        // Is the target pixel in the screen?
        if (hClip.x > 1.0 || hClip.x < -1.0 || hClip.y > 1.0 || hClip.y < -1.0 )
            continue;

        float2 nDC = hClip.xy * 0.5 + 0.5;
    #if UNITY_UV_STARTS_AT_TOP
        nDC.y = 1.0 - nDC.y;
    #endif

        uint2 tapCoord = nDC * _ScreenSize.xy;
        const BilateralData tapData = TapBilateralData(tapCoord);

        if (tapData.z01 == UNITY_RAW_FAR_CLIP_VALUE || abs(tapData.zNF - hClip.w) > 0.1)
            continue;
        float3 realWSPos = ComputeWorldSpacePosition(nDC, tapData.z01, UNITY_MATRIX_I_VP);

        float r = length(sample);
        // Compute the weight (skip computation for the center)
        const float w = r > 0.001f ? gaussian(r, sigma) * ComputeBilateralWeight(center, tapData) : 1.0;

    #if SINGLE_CHANNEL
        colorSum += LOAD_TEXTURE2D_X(_DenoiseInputTexture, tapCoord).x * w;
    #else
        colorSum += LOAD_TEXTURE2D_X(_DenoiseInputTexture, tapCoord).xyz * w;
    #endif
        wSum += w;
    }

    if (wSum == 0.0)
    {
        #if SINGLE_CHANNEL
        colorSum += LOAD_TEXTURE2D_X(_DenoiseInputTexture, centerCoord).x;
    #else
        colorSum += LOAD_TEXTURE2D_X(_DenoiseInputTexture, centerCoord).xyz;
    #endif
        wSum += 1.0;
    }

    // Store the intermediate result
    #if SINGLE_CHANNEL
    _DenoiseOutputTextureRW[COORD_TEXTURE2D_X(centerCoord)] = colorSum / wSum;
    #else
    _DenoiseOutputTextureRW[COORD_TEXTURE2D_X(centerCoord)] = float4(colorSum / wSum, 1.0);
    #endif
}

[numthreads(SPATIO_TEMPORAL_TILE_SIZE, SPATIO_TEMPORAL_TILE_SIZE, 1)]
void GATHER_FILTER(uint2 groupThreadId : SV_GroupThreadID, uint2 groupId : SV_GroupID)
{
    // Fetch the current pixel coordinate
    uint2 centerCoord = groupId * SPATIO_TEMPORAL_TILE_SIZE + groupThreadId;

    uint2 corner = centerCoord - uint2(centerCoord.x & 1, centerCoord.y & 1);
    #if SINGLE_CHANNEL
    float color = LOAD_TEXTURE2D_X(_DenoiseInputTexture, corner).x;
    color += LOAD_TEXTURE2D_X(_DenoiseInputTexture, corner + uint2(1, 0)).x;
    color += LOAD_TEXTURE2D_X(_DenoiseInputTexture, corner + uint2(0, 1)).x;
    color += LOAD_TEXTURE2D_X(_DenoiseInputTexture, corner + uint2(1, 1)).x;
    color *= 0.25;
    _DenoiseOutputTextureRW[COORD_TEXTURE2D_X(centerCoord)] = color;
    #else
    float3 color = LOAD_TEXTURE2D_X(_DenoiseInputTexture, corner).xyz;
    color += LOAD_TEXTURE2D_X(_DenoiseInputTexture, corner + uint2(1, 0)).xyz;
    color += LOAD_TEXTURE2D_X(_DenoiseInputTexture, corner + uint2(0, 1)).xyz;
    color += LOAD_TEXTURE2D_X(_DenoiseInputTexture, corner + uint2(1, 1)).xyz;
    color *= 0.25;
    _DenoiseOutputTextureRW[COORD_TEXTURE2D_X(centerCoord)] = float4(color, 1.0);
    #endif
}
